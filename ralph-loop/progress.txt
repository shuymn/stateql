## Codebase Patterns
- For orchestrator dry-run wiring, keep `DiffEngine::diff_with_diagnostics(...)` as the single diff entrypoint and convert `DiffDiagnostics.skipped_ops` into renderer comment lines (`-- Skipped: <kind>`) before appending statement rendering so suppression visibility stays consistent.
- For dry-run statement rendering, keep `Renderer` as the single statement-to-text boundary: emit each SQL statement with a trailing newline, map `Statement::BatchBoundary` through `Dialect::batch_separator()`, and normalize separator newlines so dialects can return either `GO` or `GO\n` safely.
- For executor failure diagnostics, map adapter and transaction errors through a shared statement-error builder that merges current statement metadata with inherited execution location/context, and box statement_context in ExecutionError to avoid clippy result_large_err regressions.
- For executor `BatchBoundary` semantics, treat `Statement::BatchBoundary` as a cursor-advance no-op both inside transactional scans and top-level dispatch so `T,T,B,T` stays in one transaction while preserving sync-point ordering.
- For executor `transactional:false` boundaries, keep transactional runs as contiguous groups (`T*`) and execute non-transactional SQL directly between groups, with a shared `flush_tx_if_open` commit helper so boundary behavior stays explicit ahead of `BatchBoundary` tasking.
- For executor transaction grouping, scan `Statement` slices into contiguous transactional runs and execute each run through a single RAII `Transaction`, while keeping unsupported statement kinds as explicit fail-fast branches until their dedicated tasks land.
- For circular FK fallback, preprocess dependency graphs in `crates/core/src/diff/cycle.rs` so only cycle-forming FK edges are split into `AddForeignKey`/`DropForeignKey` ops, while self-referential FKs stay embedded on `CreateTable`.
- For DDL planning boundaries, keep `DdlPlanner`/`DdlPlan` in `crates/core/src/plan.rs` and route `DiffEngine` ordering through `build_ddl_plan(...)` so ordering rules stay single-sourced in Task 22 sorter logic.
- For deterministic diff ordering, centralize sort logic in `crates/core/src/ordering.rs` with explicit priority/sub-priority enums and apply dependency topological sorting only inside the relevant priority groups (`CreateTable`, `CreateView`), while preserving original declaration order as the fallback tie-breaker.
- For view rebuild closure, derive changed-view dependents from the current schema graph and emit `DropView` in reverse topological order plus `CreateView` in desired topological order, so unchanged dependent views are rebuilt deterministically.
- For privilege diff semantics, match entries by `(on, grantee)` and compute operation deltas through a canonical helper (`diff_privilege_ops`) so list ordering/duplicates do not affect emitted minimal `Grant/Revoke` changes.
- For constraint-modification exceptions under `enable_drop=false`, emit matched drop+add pairs from compare logic via a shared constraint-key helper so general suppression/diagnostics flow remains unchanged for truly destructive drops.
- For `enable_drop` diagnostics, keep current diff emission logic as the source of truth and derive skipped destructive diagnostics by comparing an `enable_drop=true` pass with emitted ops through a centralized `SkippedOpKind` table, so future exceptions (like paired drops) can remain emitted without breaking diagnostics accounting.
- For `schema_search_path` support in diff matching, keep strict key lookup first and run a dedicated fallback resolver only on misses so qualified/unqualified matching stays deterministic (first search-path schema wins) without interfering with rename resolution.
- For rename-aware diffing, keep strict name matching as the default path and run `resolve_rename_match(...)` only for unmatched desired objects so annotated renames emit `Rename*` ops without reintroducing drop/create churn.
- For partition diffing in `DiffEngine`, delegate table partition logic to a dedicated `diff::partition` module and perform a two-stage compare (partition key: strategy+columns, then partition elements) so add/drop/change decomposition stays isolated from column/check comparison code.
- For expanding `SchemaObject` diff coverage incrementally, keep `match SchemaObject` paths exhaustive (no wildcard arms) and route not-yet-supported variants through explicit `DiffError` fail-fast checks.
- For staged diff-engine development, keep `DiffEngine::diff` split into explicit phases (`compare_*` first, then a dedicated resolve/order hook) so name resolution and ordering tasks can evolve without coupling to object-diff logic.
- For injected semantic-equivalence hooks, keep strict equality as the first-stage gate via a shared fallback helper (`strict_or_policy`) and enforce policy purity assumptions with a reusable contract validator (symmetry + repeated-call stability checks).
- For dialect-specific `Column.extra` metadata, define key constants in core (`stateql_core::extra_keys::<dialect>::*`) and consume those constants in fixtures/tests to prevent parser/generator key drift before dialect implementations land.
- For wide contract enums under workspace `-D warnings`, pair an exhaustive variant-tag `match` helper with an `all_*_variants()` fixture list; this catches new-variant drift at compile time, and if `clippy::large_enum_variant` fires, box only the largest payload field instead of suppressing the lint.
- For fail-fast rename annotation attachment, first resolve every line->target binding into immutable operations, then mutate IR objects in a second pass so orphan annotations cannot partially set `renamed_from`.
- For comment-driven SQL metadata (for example `@renamed`), run a quote-aware line-comment scan and strip only the matched annotation token so cleaned SQL keeps original line boundaries for parser error mapping.
- When extending shared enum payloads (for example `Statement::Sql`), update the core enum, root re-exports, and all contract-test constructors in one task so workspace-wide quality gates catch no stale struct literals.
- For multi-phase IR growth, add new object-family structs/enums in one module pass and update both `ir.rs` and `lib.rs` re-exports in the same change so downstream crate imports never drift during task boundaries.
- For staged IR expansion, move growing object families into `src/ir/<domain>.rs` and switch enum variants to typed payload structs in one change, then immediately update cross-crate fixture constructors to keep workspace-wide tests green.
- For recursive IR expression trees, keep payload recursion explicit with `Box<Expr>` and isolate shared query/window payloads (`SubQuery`, `WindowSpec`) in a dedicated `ir/expr.rs` module, then re-export through `ir.rs` and `lib.rs` to stabilize downstream imports.
- For IR enums that must keep `Value::Float(f64)`, use `PartialEq` for the base type and provide a dedicated `f64::total_cmp`-based helper (for Eq-like paths) instead of introducing `ordered-float`.
- For RAII transaction contracts, centralize `COMMIT`/`ROLLBACK` behavior inside `stateql_core::Transaction` and keep adapter implementations focused on connection-specific `execute`/`begin` plumbing.
- For trait-contract expansion tasks, lock the required method set with a dedicated core integration test (`crates/core/tests/*_contract_test.rs`) that calls each trait method, then update every dialect crate in the same change so `cargo check --workspace` stays green.
- Keep shared cross-crate contract types in a dedicated `src/*.rs` module and re-export them from `lib.rs` so integration tests and downstream crates can use stable root paths.
- Task boundary tests live under `crates/core/tests/` and can enforce source-level boundaries by reading `src/*.rs` via `env!("CARGO_MANIFEST_DIR")`.
- Keep early-phase core placeholders as minimal re-exported stubs in `crates/core/src/lib.rs` so downstream dialect crates continue compiling.
- For early contract tasks, `#[path = "../src/*.rs"]` tests in `crates/core/tests/` are useful to lock internal type shapes before public re-exports are finalized.
- Promote stage errors through a single `stateql_core::Error` + `stateql_core::Result<T>` boundary, then propagate that alias through core traits and dialect stubs to keep signatures consistent.

---

## 2026-02-22 - task-0: Remove Bootstrap Placeholders
- What was implemented: Removed bootstrap placeholders (`plan_diff`, smoke test, and legacy diff variants) and kept Task 0 stubs (`CoreError/CoreResult`, `Ident`, `SchemaObject`, `DiffOp`, `Statement`, `Dialect`) as compile boundaries.
- Files changed: `crates/core/src/lib.rs`, `crates/core/src/ir.rs`, `crates/core/src/diff.rs`, `crates/core/tests/bootstrap_boundary_test.rs`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test bootstrap_boundary_test`: PASS (2 passed, 0 failed).
  - `rg -n "plan_diff|CreateObject|DropObject|smoke_parse_diff_render" crates/core -S`: no matches.
  - `cargo check -p stateql-core`: PASS.
  - Public Task 0 error boundary (`CoreError/CoreResult`) verified in `bootstrap_boundary_test`.
- **Learnings:**
  - Patterns discovered: Use integration tests to pin "removed symbol" boundaries with file-content assertions while avoiding hard-coded legacy tokens in source.
  - Gotchas encountered: `.git` is read-only in this sandbox (`index.lock` cannot be created), so `git add`/`git commit` cannot run here.
---

## 2026-02-22 - task-1: Add Stage-Typed Error Enums
- What was implemented: Added stage-typed errors (`ParseError`, `DiffError`, `GenerateError`, `ExecutionError`) and `SourceLocation`, plus RED->GREEN tests that assert typed variants and parse context retention on `ParseError::StatementConversion`.
- Files changed: `crates/core/src/error.rs`, `crates/core/tests/error_types_test.rs`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test error_types_test`: PASS (2 passed, 0 failed).
  - `ParseError::StatementConversion` statement context + `SourceLocation` retention: PASS in `parse_error_statement_conversion_keeps_statement_context_and_location`.
- **Learnings:**
  - Patterns discovered: Boundary-phase error contracts can be pinned with integration tests that include source modules directly while public exports are still in flux.
  - Gotchas encountered: `thiserror` download failed in this sandbox (`index.crates.io` DNS resolution error), so manual `Display`/`Error` impls were used; `git commit` still fails because `.git/index.lock` cannot be created.
---

## 2026-02-22 - task-2: Add Top-Level Error and Result<T>
- What was implemented: Added top-level `Error` (`Parse`, `Diff`, `Generate`, `Execute`) with `From` conversions and `Result<T>` alias in core; exported the typed errors and alias via `stateql_core`; added RED->GREEN wrapper tests; refactored core public trait signatures (`Dialect`, `DatabaseAdapter`) and all dialect stub implementations to return `Result<T>`.
- Files changed: `crates/core/src/error.rs`, `crates/core/src/lib.rs`, `crates/core/src/adapter.rs`, `crates/core/src/dialect.rs`, `crates/core/tests/error_wrap_test.rs`, `crates/core/tests/bootstrap_boundary_test.rs`, `crates/dialect-postgres/src/lib.rs`, `crates/dialect-mysql/src/lib.rs`, `crates/dialect-sqlite/src/lib.rs`, `crates/dialect-mssql/src/lib.rs`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test error_wrap_test`: PASS (2 passed, 0 failed).
  - `rg -n "fn (parse|generate_ddl|export_schema|execute).*-> Result<" crates/core/src/{dialect.rs,adapter.rs}`: PASS (core public API returns `Result<T>`).
  - Additional verification: `cargo nextest run -p stateql-core` PASS (6 passed, 0 failed), `cargo check` PASS.
- **Learnings:**
  - Patterns discovered: Wrapper-layer tests should hit public crate exports (`stateql_core::{Error, Result, ...}`) to lock both type shape and re-export boundaries in one place.
  - Gotchas encountered: commit is still blocked in this sandbox because `.git/index.lock` cannot be created (`Operation not permitted`).
---

## 2026-02-22 - task-3: Add Version and ConnectionConfig
- What was implemented: Added `Version { major, minor, patch }` and v1 `ConnectionConfig` (`host`, `port`, `user`, `password`, `database`, `socket`, `extra`) in new `config.rs`, re-exported both from `stateql_core`, and added RED->GREEN integration tests that construct and assert both types.
- Files changed: `crates/core/src/config.rs`, `crates/core/src/lib.rs`, `crates/core/tests/config_types_test.rs`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test config_types_test`: PASS (2 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Contract-foundation tasks can use constructor-by-literal tests in `crates/core/tests/` to lock field names/types before trait signatures start depending on them.
  - Gotchas encountered: commit remains blocked in this sandbox (`.git/index.lock` cannot be created), so the plan-specified commit command could not complete.
---

## 2026-02-22 - task-4: Expand Dialect Trait to Full Contract
- What was implemented: Expanded `stateql_core::Dialect` to the full v1 contract (`to_sql`, `normalize`, `equivalence_policy`, `quote_ident`, `batch_separator`, `connect`) with `name()` returning `&str`; added `EquivalencePolicy` + `DEFAULT_EQUIVALENCE_POLICY` in core; added RED->GREEN contract test; updated all dialect stubs to implement the expanded trait and return explicit stage-typed `Parse`/`Generate`/`Execute` errors for unimplemented paths.
- Files changed: `crates/core/src/dialect.rs`, `crates/core/src/lib.rs`, `crates/core/tests/dialect_contract_test.rs`, `crates/dialect-postgres/src/lib.rs`, `crates/dialect-mysql/src/lib.rs`, `crates/dialect-sqlite/src/lib.rs`, `crates/dialect-mssql/src/lib.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test dialect_contract_test`: PASS (1 passed, 0 failed).
  - `cargo check --workspace`: PASS (core + all dialect crates compile; workspace check green).
- **Learnings:**
  - Patterns discovered: Keep unimplemented dialect stub paths fail-fast by returning typed stage errors instead of placeholder success values, so later parser/generator work cannot silently pass.
  - Gotchas encountered: Plan text mentions typed errors for `normalize`, but `normalize` has no `Result` in the contract; treated as no-op and used typed errors for `to_sql`/`connect`/stub parse+generate paths.
---

## 2026-02-22 - task-5: Implement Single-Connection Adapter + RAII Transaction
- What was implemented: Finalized `DatabaseAdapter` to the v1 synchronous single-connection contract (`export_schema`, `execute(&self, &str)`, `begin`, `schema_search_path`, `server_version`) and introduced RAII `Transaction` with `execute`, `commit`, and drop-time rollback; added dedicated Task 5 RED->GREEN tests plus an in-memory reusable fake adapter test foundation based on interior mutability (`RefCell`).
- Files changed: `crates/core/src/adapter.rs`, `crates/core/src/lib.rs`, `crates/core/tests/transaction_raii_test.rs`, `crates/core/tests/adapter_sync_contract_test.rs`, `crates/core/tests/support/fake_adapter.rs`, `crates/core/tests/dialect_contract_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test transaction_raii_test`: PASS (2 passed, 0 failed).
  - `cargo nextest run -p stateql-core --test adapter_sync_contract_test`: PASS (2 passed, 0 failed).
  - `crates/core/tests/support/fake_adapter.rs`: PASS (added reusable in-memory fake with execution log, begin/commit/rollback counters, configurable schema/version/failure hooks for Task 24-30 reuse).
- **Learnings:**
  - Patterns discovered: Signature contracts that must remain sync-only can be locked with function-pointer type assertions (`fn(&T, &str) -> Result<()>`, `for<'a> fn(&'a mut T) -> Result<Transaction<'a>>`) to fail fast if async/Future leaks into core traits.
  - Gotchas encountered: A default `begin()` implementation that builds `Transaction` from `self` breaks on unsized `Self`; keep `begin` explicit in impls and expose `Transaction::new` for adapter implementers.
---

## 2026-02-22 - task-6: Add IR Foundations (`Ident`, `QualifiedName`, `Value`, `DataType`)
- What was implemented: Split `core::ir` into module roots (`ir/ident.rs`, `ir/types.rs`), added canonical foundational types (`Ident`, `QualifiedName`, `Value`, `DataType`), preserved the current Task 0-7 `SchemaObject` stub shape, added explicit float comparison helpers (`float_total_cmp`, `value_total_eq`), and added `Ident::quoted/unquoted` constructors.
- Files changed: `crates/core/src/ir.rs`, `crates/core/src/ir/ident.rs`, `crates/core/src/ir/types.rs`, `crates/core/src/lib.rs`, `crates/core/tests/ir_foundation_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test ir_foundation_test`: PASS (2 passed, 0 failed).
  - `cargo check -p stateql-dialect-postgres -p stateql-dialect-mysql -p stateql-dialect-sqlite -p stateql-dialect-mssql`: PASS.
- **Learnings:**
  - Patterns discovered: Keep `Value::Float(f64)` in canonical IR and enforce deterministic equality needs through a dedicated `total_cmp` helper, while regular IR comparisons remain `PartialEq`.
  - Gotchas encountered: `NaN` intentionally fails `PartialEq`; tests should pin both behaviors (`PartialEq` vs total-order helper) to avoid accidental equality semantics drift.
---

## 2026-02-22 - task-7: Add Expression AST Core Variants
- What was implemented: Added a new `ir/expr.rs` module with core expression AST coverage required by the plan (`Expr`, `Literal`, `BinaryOperator`, `UnaryOperator`, `ComparisonOp`, `IsTest`, `SetQuantifier`, `WindowSpec`, `SubQuery`), wired exports through `ir.rs` and `lib.rs`, and completed RED->GREEN using `expr_ast_test`.
- Files changed: `crates/core/src/ir.rs`, `crates/core/src/ir/expr.rs`, `crates/core/src/lib.rs`, `crates/core/tests/expr_ast_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test expr_ast_test`: PASS (2 passed, 0 failed).
  - `cargo check -p stateql-dialect-postgres -p stateql-dialect-mysql -p stateql-dialect-sqlite -p stateql-dialect-mssql`: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (17 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep expression variants grouped by intent (leaf/operator/range/function/compound/fallback) so future variant additions remain localized and readable.
  - Gotchas encountered: Clippy `approx_constant` (`3.14`) can fail test code under workspace-wide `-D warnings`; use `std::f64::consts::PI` in fixture literals.
---

## 2026-02-22 - task-8: Add Full `SchemaObject` Family (Part 1)
- What was implemented: Added a dedicated `ir/schema_object.rs` module and replaced the temporary `SchemaObject` stub with typed top-level variants (`Table`, `View`, `MaterializedView`, `Index`, `Sequence`), plus part-1 IR structs/enums (`Column`, `Identity`, `GeneratedColumn`, `PrimaryKey`, `TableOptions`, `IndexDef`, `IndexColumn`, `IndexOwner`, `Partition`, `PartitionStrategy`, `PartitionElement`, `PartitionBound`, `Sequence`, `ColumnPosition`) and constructors (`Table::named`, `View::new`); updated existing fixtures/tests that still used the old struct-style `SchemaObject::Table` variant shape.
- Files changed: `crates/core/src/ir.rs`, `crates/core/src/ir/schema_object.rs`, `crates/core/src/lib.rs`, `crates/core/tests/schema_object_part1_test.rs`, `crates/core/tests/dialect_contract_test.rs`, `crates/testkit/src/lib.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test schema_object_part1_test`: PASS (2 passed, 0 failed).
  - `cargo check -p stateql-dialect-postgres -p stateql-dialect-mysql -p stateql-dialect-sqlite -p stateql-dialect-mssql`: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (19 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: When promoting placeholder enum variants to typed payload structs, keep constructor helpers (`Table::named`, `View::new`) in the same module so downstream fixtures can migrate with minimal noise.
  - Gotchas encountered: Legacy fixtures in non-core crates (`testkit`) can still rely on old variant constructor shape even if core unit tests pass; include a workspace-wide run before marking the task done.
---

## 2026-02-22 - task-9: Add Full `SchemaObject` Family (Part 2)
- What was implemented: Expanded `SchemaObject` to the full part-2 family (`Trigger`, `Function`, `Type`, `Domain`, `Extension`, `Schema`, `Comment`, `Privilege`, `Policy`), added all plan-required support types (`CheckConstraint`, `ExclusionConstraint`, `ExclusionElement`, `Deferrable`, `SortOrder`, `NullsOrder`, `ForeignKey`, `ForeignKeyAction`, `CheckOption`, `ViewSecurity`, `TriggerTiming`, `TriggerEvent`, `TriggerForEach`, `FunctionParam`, `FunctionParamMode`, `Volatility`, `FunctionSecurity`, `PrivilegeOp`, `PrivilegeObject`, `PolicyCommand`, `TypeKind`, `EnumValuePosition`, `CommentTarget`), added `Privilege::empty`, and aligned existing IR structs (`Table`, `View`, `MaterializedView`) plus crate re-exports to the expanded contract.
- Files changed: `crates/core/src/ir.rs`, `crates/core/src/ir/schema_object.rs`, `crates/core/src/lib.rs`, `crates/core/tests/schema_object_part1_test.rs`, `crates/core/tests/schema_object_part2_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test schema_object_part2_test`: PASS (2 passed, 0 failed).
  - `cargo check -p stateql-dialect-postgres -p stateql-dialect-mysql -p stateql-dialect-sqlite -p stateql-dialect-mssql`: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (21 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: When adding large IR type families, constructor-focused integration tests (`schema_object_part*_test`) catch re-export and struct-shape regressions earlier than downstream crate checks.
  - Gotchas encountered: Workspace-wide clippy flags even test-only style nits (`redundant_pattern_matching`), so the quality-gate run should happen before updating tracking artifacts.
---

## 2026-02-22 - task-10: Add Statement Context Model
- What was implemented: Added statement execution context modeling to core statements by extending `Statement::Sql` with `context: Option<StatementContext>`, introducing `StatementContext::SqliteTableRebuild { table, step }` and `SqliteRebuildStep` variants, re-exporting both new types from `stateql_core`, and adding a RED->GREEN integration test that validates SQLite rebuild context retention on generated statements.
- Files changed: `crates/core/src/statement.rs`, `crates/core/src/lib.rs`, `crates/core/tests/statement_context_test.rs`, `crates/core/tests/dialect_contract_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test statement_context_test`: PASS (1 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (22 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Statement-level diagnostic metadata should be modeled as typed enums on `Statement::Sql` and propagated via `Option` so execution semantics remain unchanged while diagnostics gain structure.
- Gotchas encountered: Adding a field to shared enum variants requires immediate updates to existing contract fixtures (`Statement::Sql` constructors) or workspace-wide compilation will fail before task tests run.
---

## 2026-02-22 - task-11: Add Annotation Extractor (`@renamed`)
- What was implemented: Added core annotation extraction via `AnnotationExtractor::extract` with line-preserving SQL cleanup, comment-only `@renamed from=...` parsing, string-literal safety, and deprecated `@rename` alias acceptance via `RenameAnnotation.deprecated_alias`.
- Files changed: `crates/core/src/annotation.rs`, `crates/core/src/lib.rs`, `crates/core/tests/annotation_extractor_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test annotation_extractor_test`: PASS (2 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (24 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep rename annotation parsing in core with an explicit `deprecated_alias` marker so later parser pipelines can emit deprecation warnings without re-parsing comment tokens.
  - Gotchas encountered: Failing to preserve exact line count during annotation stripping would break downstream parser line mapping; line endings must remain untouched while removing only annotation substrings.
---

## 2026-02-22 - task-12: Add Annotation Attachment Validation
- What was implemented: Added `attach_annotations` in core with typed attachment targets (`AnnotationAttachment` / `AnnotationTarget`) that resolves annotation line bindings to IR object keys (`Table`, `View`, `MaterializedView`, and column variants), validates orphan/ambiguous matches as `DiffError`, and applies `renamed_from` updates only after full validation to keep fail-fast semantics.
- Files changed: `crates/core/src/annotation.rs`, `crates/core/src/lib.rs`, `crates/core/tests/annotation_attach_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test annotation_attach_test`: PASS (2 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (26 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Two-phase annotation attachment (resolve first, apply second) is the safest way to enforce S2 fail-fast behavior without partial IR mutation.
  - Gotchas encountered: Attachment targets need key-level matching helpers (`QualifiedName`/`Ident`) in core so parser crates can pass line mappings without coupling to mutable IR traversal internals.
---

## 2026-02-22 - task-13: Add Full `DiffOp` and Change Enums
- What was implemented: Replaced the placeholder `DiffOp` with the full typed diff surface (`DiffOp`, `ColumnChange`, `SequenceChange`, `TypeChange`, `DomainChange`), split diff into `diff.rs` module root + `diff/types.rs` + `diff/engine.rs`, re-exported the new diff types from `stateql_core`, and added reusable `all_diffop_variants()` fixtures plus diff-surface tests.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/types.rs`, `crates/core/src/diff/engine.rs`, `crates/core/src/lib.rs`, `crates/core/tests/diffop_surface_test.rs`, `crates/core/tests/support/diffop_fixtures.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test diffop_surface_test`: PASS (3 passed, 0 failed).
  - `DiffOp` variant definitions are centralized in `crates/core/src/diff/types.rs` and separated from engine scaffolding in `crates/core/src/diff/engine.rs`: PASS.
  - `all_diffop_variants()` coverage guard exists and is enforced by exhaustive `diffop_variant_tag()` matching + count/uniqueness assertions: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (29 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Exhaustive variant-tag helpers in test fixtures are an effective compile-time guard against enum-surface drift while keeping runtime assertions straightforward.
  - Gotchas encountered: Expanding `DiffOp` triggered `clippy::large_enum_variant`; boxing only the largest payload field (`AddColumn.column`) resolved it without lint suppression.
---

## 2026-02-22 - task-13b: Add IR Validation Tests for Dialect-Specific Patterns
- What was implemented: Added dedicated IR/DiffOp representability coverage for MySQL/MSSQL dialect patterns (`CHANGE COLUMN` full redefinition, `AFTER` positioning, MSSQL named DEFAULT constraints, rename ops, MySQL `AUTO_INCREMENT` metadata), introduced reusable test fixtures, added core `extra_keys` constants, and added `is_mysql_change_column_full_redefinition(...)` helper for change-set validation.
- Files changed: `crates/core/tests/ir_dialect_pattern_validation_test.rs`, `crates/core/tests/support/ir_pattern_fixtures.rs`, `crates/core/src/ir.rs`, `crates/core/src/diff/types.rs`, `crates/core/src/diff.rs`, `crates/core/src/lib.rs`, `crates/core/tests/support/diffop_fixtures.rs`, `crates/core/tests/schema_object_part1_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test ir_dialect_pattern_validation_test`: PASS (5 passed, 0 failed).
  - CI required-set gate: PASS (`ir_dialect_pattern_validation_test` is under `crates/core/tests/`, and `.github/workflows/ci.yml` test job runs `cargo test --all-features`, so this task gate is part of required CI).
  - `cargo nextest run -p stateql-core`: PASS (34 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (34 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: For representability gates that precede parser implementation, use construction-only tests against public IR/DiffOp exports and keep reusable constructors in `crates/core/tests/support/*` so later dialect crates can import the same fixtures.
  - Gotchas encountered: If constants are introduced only in private modules, integration tests cannot consume them from `stateql_core`; they must be re-exported from `lib.rs` to keep constant usage consistent across crate boundaries.
---

## 2026-02-22 - task-14: Add `EquivalencePolicy` and `DiffConfig`
- What was implemented: Added `crates/core/src/diff/policy.rs` with full `EquivalencePolicy` contract (`is_equivalent_expr`, `is_equivalent_custom_type`), `DefaultEquivalencePolicy`, `DEFAULT_EQUIVALENCE_POLICY`, `DiffConfig` (`enable_drop`, `schema_search_path`, `Arc<dyn EquivalencePolicy>`), strict-eq fallback helpers (`exprs_equivalent`, `custom_types_equivalent`), and a reusable contract validator (`verify_equivalence_policy_contract`) that detects non-symmetric and non-stable policies; wired policy exports through `diff.rs` and `lib.rs`, and updated `Dialect` to consume the policy contract from `diff`.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/policy.rs`, `crates/core/src/dialect.rs`, `crates/core/src/lib.rs`, `crates/core/tests/equivalence_policy_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test equivalence_policy_test`: PASS (3 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (37 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Contract-check helpers are easiest to keep deterministic when they evaluate both forward/backward symmetry and repeated-call stability per case index, returning a typed violation enum for focused assertions.
  - Gotchas encountered: Moving shared contracts from `dialect.rs` into `diff` requires synchronized re-export updates in `lib.rs`; otherwise integration tests fail with unresolved root imports before behavior tests run.
---

## 2026-02-22 - task-15: Implement Core Object Comparison (Table/Column/Index Baseline)
- What was implemented: Added baseline `DiffEngine` comparison in new `diff/compare.rs` with separated phases (`compare_objects` then `resolve_and_order`), implemented table create/drop diffing, column add/drop plus `AlterColumn` change detection (`SetType`, `SetNotNull`, `SetDefault`), index add/drop diffing by `(owner, name)`, policy-aware expression comparison for column defaults and named CHECK constraints, and fail-fast S5 owner validation for top-level indexes.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/lib.rs`, `crates/core/tests/diff_core_compare_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test diff_core_compare_test`: PASS (6 passed, 0 failed).
  - `DiffEngine::diff` separation check: PASS (`compare_objects(...)` and `resolve_and_order(...)` are distinct functions in `crates/core/src/diff/compare.rs`).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (43 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Splitting baseline diff into object-kind helpers (`compare_table`, `compare_columns`, `compare_indexes`) keeps Task 17+ name resolution and Task 22 ordering work additive instead of requiring rewrites.
  - Gotchas encountered: Baseline comparison currently rejects non-table/index object kinds with `DiffError` to avoid silent omissions; Task 15b needs to expand this coverage deliberately rather than weakening fail-fast behavior.
---

## 2026-02-22 - task-15b: Implement Remaining SchemaObject Comparison
- What was implemented: Added remaining-object diff comparison coverage for `View`, `MaterializedView`, `Sequence`, `Trigger`, `Function`, `Type`, `Domain`, `Extension`, `Schema`, `Comment`, and `Policy`, kept `Privilege` as explicit fail-fast unsupported, and added pre-diff sequence duplicate invariant validation for explicit `Sequence` vs implicit identity sequence overlap on both desired/current sides.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/compare_remaining.rs`, `crates/core/tests/diff_remaining_objects_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test diff_remaining_objects_test`: PASS (6 passed, 0 failed).
  - `SchemaObject` comparison routing uses exhaustive `match` handling in diff paths (no wildcard default for variant dispatch), preserving compile-time drift detection when enum variants change: PASS.
  - Duplicate sequence invariant violation (`Sequence` + identity implicit sequence overlap) verified for desired/current sides in `diff_remaining_objects_test`: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (49 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: For staged diff growth, isolate newly added object-family comparisons into a dedicated module and call it from `DiffEngine::compare_objects` so table/index baseline logic stays stable while enabling per-kind expansion.
  - Gotchas encountered: `DropSchema` uses unqualified `QualifiedName { schema: None, name }`, so tests should not assume default schema qualification for schema-drop ops.
---
## 2026-02-22 - task-15c: Implement Partition Diff Comparison (`AddPartition` / `DropPartition`)
- What was implemented: Added explicit partition diff logic by creating `crates/core/src/diff/partition.rs` and wiring `DiffEngine` table comparison to call it; implemented partition add/drop and change decomposition (`DropPartition` + `AddPartition`) including bound-sensitive detection for `MAXVALUE` and `FromTo`.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/partition.rs`, `crates/core/tests/partition_diff_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test partition_diff_test`: PASS (5 passed, 0 failed).
  - Table compare now delegates partition diff responsibility to `partition::diff_partition(...)`: PASS (`crates/core/src/diff/compare.rs`).
  - Task 22 (22h) ordering linkage for partition ops: PASS via explicit drop-before-add assertion on bound change in `partition_diff_test` (`treats_from_to_bound_change_as_partition_change`).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (54 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Comparing partition key (`strategy` + normalized partition columns) before element-level diffing avoids mixing table-level partition-shape changes with per-partition add/drop reconciliation.
  - Gotchas encountered: Iterating a `BTreeMap<_, &PartitionElement>` yields `&&PartitionElement`; the diff helper must clone from dereferenced values (`(*element).clone()`) to build owned `DiffOp` payloads cleanly.
---
## 2026-02-22 - task-16: Implement Rename Detection from `renamed_from`
- What was implemented: Added rename-aware matching to `DiffEngine` for tables and columns using `renamed_from`, added index rename detection via `IndexDef.extra["stateql.renamed_from"]`, introduced `diff::rename` helpers (`resolve_rename_match`, index metadata decoding, and rename-equivalence normalization), and added RED->GREEN coverage for table/column/index rename plus no-annotation fallback behavior.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/rename.rs`, `crates/core/tests/rename_detection_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test rename_detection_test`: PASS (4 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (58 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Normalize index definitions by stripping rename metadata before equality comparison so index rename annotations do not force false add/drop diffs.
  - Gotchas encountered: `IndexDef` has no dedicated `renamed_from` field yet, so explicit index rename intent must currently be carried through `extra` metadata (`stateql.renamed_from`) until parser attachment adds first-class support.
---
## 2026-02-22 - task-17: Implement Name Matching with `schema_search_path`
- What was implemented: Added `diff::name_resolution` helpers and wired `DiffEngine` table/index matching to resolve qualified/unqualified names using `DiffConfig.schema_search_path` while preserving strict exact-key matching as the first path and rename matching as the later fallback. Added dedicated RED->GREEN tests for match/mismatch behavior and first-match ordering.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/name_resolution.rs`, `crates/core/tests/schema_search_path_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test schema_search_path_test`: PASS (4 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (62 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Centralize qualified/unqualified fallback matching in a small resolver module and call it from each object-key path (table/index) to keep compare-phase logic readable and consistent.
  - Gotchas encountered: To keep ADR-0014 “first search path match wins” deterministic, resolution should construct candidate keys in search-path order instead of scanning map iteration order.
---
## 2026-02-22 - task-18: Implement `enable_drop` Suppression Diagnostics
- What was implemented: Added a dedicated `diff::enable_drop` module with `DiffDiagnostics`/`SkippedOpDiagnostic` payloads and a constant `SkippedOpKind` suppression table; extended `DiffEngine` with `diff_with_diagnostics(...)` that preserves existing diff behavior while returning skipped destructive operations as diagnostics when `enable_drop=false`.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/enable_drop.rs`, `crates/core/src/lib.rs`, `crates/core/tests/enable_drop_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test enable_drop_test`: PASS (2 passed, 0 failed).
  - `enable_drop_test` verifies suppressed op count and diagnostics payload kind/content for `DropTable` and `Revoke`: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (64 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: A two-pass diff (`enable_drop=false` emitted ops plus `enable_drop=true` reference ops) lets diagnostics capture suppressed destructive operations without changing existing compare-path behavior.
  - Gotchas encountered: `Privilege` in current IR uses `operations: Vec<PrivilegeOp>` and `on`/`with_grant_option` fields, so suppression tests for `Revoke` must construct that exact shape.
---
## 2026-02-22 - task-19: Implement Constraint Modification Pairing
- What was implemented: Added a dedicated constraint-pairing helper module and integrated it into check-constraint diffing so named CHECK constraint body changes emit `DropCheck + AddCheck` as a pair even when `enable_drop=false`, while unpaired destructive drops remain suppressed.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/constraint_pairing.rs`, `crates/core/tests/constraint_pairing_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test constraint_pairing_test`: PASS (2 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (66 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keeping pairing logic in a small key-matching helper avoids scattering special-case `enable_drop` exceptions across compare code paths.
  - Gotchas encountered: The existing compare path only pairs named CHECK constraints today; unnamed fallback pairing from the design note will require broader constraint matching when unnamed CHECK diff support is expanded.
---
## 2026-02-22 - task-20: Implement Privilege Set-Difference Semantics
- What was implemented: Added dedicated privilege diff logic with `(on, grantee)` matching and canonical operation set-difference (`diff_privilege_ops`), emitting minimal `Grant/Revoke` ops for added/removed operations plus `with_grant_option` deltas; integrated privilege comparison into remaining-object diff flow and removed the previous privilege fail-fast path.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/privilege.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/compare_remaining.rs`, `crates/core/tests/privilege_diff_test.rs`, `crates/core/tests/diff_remaining_objects_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test privilege_diff_test`: PASS (4 passed, 0 failed).
  - `cargo +nightly-2026-02-20 fmt --all`: PASS.
  - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
  - `cargo nextest run --workspace`: PASS (70 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep privilege-op comparison isolated in a canonical set helper so emit logic can separately compose operation diffs and grant-option-only diffs without depending on input ordering.
  - Gotchas encountered: For `with_grant_option` downgrade, shared operations must emit `Revoke` with `with_grant_option=true` (grant-option revoke semantics) while removed operations should still revoke the privilege itself (`with_grant_option=false`).
---
## 2026-02-22 - task-21: Implement View Rebuild Closure Expansion
- What was implemented: Added dependent-view rebuild closure expansion for changed views, including transitive dependency traversal and deterministic drop/create ordering; refactored view dependency graph construction into a dedicated `diff/view_rebuild.rs` module and wired view diff comparison to use it.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare_remaining.rs`, `crates/core/src/diff/view_rebuild.rs`, `crates/core/tests/view_rebuild_scope_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test view_rebuild_scope_test`: PASS (2 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (72 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep view rebuild planning as a dedicated closure planner that consumes current/desired view graphs and returns ordered keys, so compare logic stays focused on op emission.
  - Gotchas encountered: Dependency extraction from raw view SQL must resolve unqualified relation names using the source view schema first; otherwise unchanged dependents can be missed when names are schema-qualified in IR.
---
## 2026-02-22 - task-22: Implement Diff Ordering Priorities
- What was implemented: Added deterministic diff ordering in a new root `ordering` module with explicit priority (`1..30`) and table sub-priority (`22a..22i`) enums; wired `DiffEngine::resolve_and_order` to use the sorter; added dependency-aware ordering for `CreateTable` (FK graph) and `CreateView` (view reference graph) with declaration-order fallback; added Task 22 RED->GREEN contract tests and updated one pre-existing search-path test expectation to reflect global drop-before-create ordering.
- Files changed: `crates/core/src/ordering.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff.rs`, `crates/core/src/lib.rs`, `crates/core/tests/diff_ordering_test.rs`, `crates/core/tests/schema_search_path_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test diff_ordering_test`: PASS (6 passed, 0 failed).
  - `diff_ordering_test` fixture verifies `DESIGN.md` priority `1..30` coverage (no missing lines) and enforces `22a..22i`, FK/view dependency ordering, and declaration-order fallback: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (78 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep priority-aware ordering as a pure sorter over `Vec<DiffOp>` so compare logic remains focused on diff emission while ordering-specific evolution stays isolated.
  - Gotchas encountered: Introducing global ordering can invalidate older tests that asserted incidental emission order; behavior-focused tests should assert deterministic ordering contract or membership unless sequence is part of the spec.
---
## 2026-02-22 - task-22b: Implement Dedicated DDL Planner Module (`plan.rs`)
- What was implemented: Added a dedicated planning module (`crates/core/src/plan.rs`) with `DdlPlanner`, `DdlPlan`, and `build_ddl_plan(...)`; moved planner-facing ordering access from `diff` to `plan`; updated `DiffEngine::resolve_and_order` to delegate through the planner so ordering remains centralized in Task 22 sorter behavior.
- Files changed: `crates/core/src/plan.rs`, `crates/core/src/lib.rs`, `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/tests/ddl_plan_builder_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test ddl_plan_builder_test`: PASS (2 passed, 0 failed).
  - Planner API is exported via `stateql_core` (`DdlPlanner`, `DdlPlan`, `build_ddl_plan`, `sort_diff_ops`) and validated by integration tests importing root exports: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (80 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep planner construction API as a thin boundary over deterministic sorting so orchestrator/executor tasks can consume a stable plan type without re-embedding ordering rules.
  - Gotchas encountered: Re-exporting `sort_diff_ops` from both `diff` and `plan` causes duplicate root imports; planner boundary migration needs a single export source (`plan`).
---
## 2026-02-22 - task-23: Implement Circular FK Fallback
- What was implemented: Added dedicated circular-FK graph handling and wired it into `DiffEngine` so create-side FK cycles are split into `AddForeignKey` ops after `CreateTable`, drop-side FK cycles emit `DropForeignKey` before `DropTable`, and self-referential FKs are excluded from cycle fallback.
- Files changed: `crates/core/src/diff.rs`, `crates/core/src/diff/compare.rs`, `crates/core/src/diff/cycle.rs`, `crates/core/tests/circular_fk_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test circular_fk_test`: PASS (3 passed, 0 failed).
  - `circular_fk_test` explicitly verifies CREATE fallback, DROP fallback, and self-FK exclusion: PASS.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (83 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Preserve declaration-order semantics for create/drop table passes by iterating table buckets in source order and keeping cycle-specific graph logic isolated from general ordering priorities.
  - Gotchas encountered: Drop-side cycle fallback can only produce `DropForeignKey` for named constraints (`ForeignKey.name: Some(...)`), so unnamed FKs remain drop-by-table behavior.
---
## 2026-02-22 - task-24: Implement Executor Transaction Grouping
- What was implemented: Added a new `Executor` in core with `execute_plan` that groups consecutive transactional `Statement::Sql` items into a single transaction and commits once per group, plus helper-split transaction state flow (`execute_next_group` / `execute_transactional_group`) and a RED->GREEN grouping test using the shared in-memory fake adapter.
- Files changed: `crates/core/src/executor.rs`, `crates/core/src/lib.rs`, `crates/core/tests/executor_grouping_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test executor_grouping_test`: PASS (1 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (84 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Segment-based execution (contiguous transactional run -> one transaction) keeps grouping logic deterministic and avoids long-lived mutable-borrow state inside the executor loop.
  - Gotchas encountered: Keeping a `Transaction<'_>` in an outer mutable state holder can complicate adapter borrow lifetimes; executing one transactional run at a time keeps borrow scopes simple.
---
## 2026-02-22 - task-25: Implement Non-Transactional Boundary Handling
- What was implemented: Added executor support for `transactional:false` statements by executing them directly on the adapter between transactional groups, introduced `flush_tx_if_open(...)` for shared commit handling, and added RED->GREEN coverage for `T,T,N,T,T` boundary semantics and execution ordering.
- Files changed: `crates/core/src/executor.rs`, `crates/core/tests/executor_non_transactional_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test executor_non_transactional_test`: PASS (1 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (85 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep `Executor` boundary behavior as `transactional` segment execution + direct non-transactional dispatch, so commit-before / begin-after semantics are guaranteed by segment transitions without long-lived transaction state.
  - Gotchas encountered: `Statement::BatchBoundary` remains fail-fast in Task 25 by design; changing it here would violate task sequencing and overlap Task 26 semantics.
---
## 2026-02-22 - task-26: Implement BatchBoundary No-Commit Semantics
- What was implemented: Added Task 26 `BatchBoundary` execution semantics in `Executor` by treating `Statement::BatchBoundary` as a synchronization no-op (no SQL emission, no commit trigger) both in top-level dispatch and while scanning transactional groups, so `T,T,B,T` remains one transaction.
- Files changed: `crates/core/src/executor.rs`, `crates/core/tests/executor_batchboundary_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test executor_batchboundary_test`: PASS (1 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (86 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Batch-boundary behavior is safest when modeled as cursor advancement in the executor loop, avoiding any hidden transaction lifecycle side effects.
  - Gotchas encountered: Handling `BatchBoundary` only in top-level dispatch is insufficient because transactional-run scanners can still split runs at boundaries and inadvertently introduce extra commits.
---
## 2026-02-22 - task-27: Propagate Execution Context into `ExecutionError`
- What was implemented: Added `ExecutionError::StatementFailed.statement_context` and an `ExecutionError::statement_failed(...)` builder, then updated `Executor` to map adapter/transaction failures into statement-scoped execution errors with statement index, SQL text, executed statement count, inherited source location, and propagated `Statement::Sql.context`.
- Files changed: `crates/core/src/error.rs`, `crates/core/src/executor.rs`, `crates/core/tests/execution_error_context_test.rs`, `crates/core/tests/error_types_test.rs`, `crates/core/tests/error_wrap_test.rs`, `crates/core/tests/support/fake_adapter.rs`, `crates/dialect-postgres/src/lib.rs`, `crates/dialect-mysql/src/lib.rs`, `crates/dialect-sqlite/src/lib.rs`, `crates/dialect-mssql/src/lib.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test execution_error_context_test`: PASS (1 passed, 0 failed).
  - Failure-path contract verified in test: `statement_index=1`, failed SQL text matches, `executed_statements=1`, and `statement_context` is propagated from `Statement::Sql.context`.
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (87 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep execution error mapping centralized in `Executor` so statement metadata is attached consistently for begin/execute/commit failure paths.
  - Gotchas encountered: Adding full `StatementContext` directly to `ExecutionError` triggered `clippy::result_large_err`; boxing that payload (`Option<Box<StatementContext>>`) preserves typed diagnostics while keeping workspace lints green.
---
## 2026-02-22 - task-28: Implement Renderer with Dialect Separator
- What was implemented: Added core `Renderer` with `Renderer::new(&dyn Dialect)` and `render(&[Statement]) -> String`; SQL statements are rendered line-by-line and `Statement::BatchBoundary` is converted to the dialect separator with newline normalization (e.g., `GO` -> `GO\n`).
- Files changed: `crates/core/src/renderer.rs`, `crates/core/src/lib.rs`, `crates/core/tests/renderer_test.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test renderer_test`: PASS (1 passed, 0 failed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (88 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep renderer output deterministic by making newline handling explicit for both SQL lines and dialect separators.
  - Gotchas encountered: Dialect separators may already include a trailing newline; renderer-level normalization avoids duplicate blank lines in dry-run output.
---
## 2026-02-22 - task-29: Implement Orchestrator `--dry-run` and `--apply`
- What was implemented: Added core orchestrator flow with `Mode::{Apply,DryRun}` and a single `run(...)` entrypoint that performs parse -> normalize -> diff -> generate, injects `DiffConfig` from runtime inputs (`enable_drop`, adapter `schema_search_path`, dialect `equivalence_policy`), executes statements for apply via `Executor`, and returns rendered SQL for dry-run with `-- Skipped:` diagnostics lines sourced from diff suppression diagnostics.
- Files changed: `crates/core/src/orchestrator.rs`, `crates/core/src/lib.rs`, `crates/core/tests/orchestrator_apply_dryrun_test.rs`, `crates/core/tests/orchestrator_diffconfig_wiring_test.rs`, `crates/core/tests/support/fake_dialect.rs`, `ralph-loop/.commit-msg`, `ralph-loop/prd.json`, `ralph-loop/progress.txt`.
- DoD verification results:
  - `cargo nextest run -p stateql-core --test orchestrator_apply_dryrun_test`: PASS (2 passed, 0 failed).
  - `cargo nextest run -p stateql-core --test orchestrator_diffconfig_wiring_test`: PASS (3 passed, 0 failed).
  - `orchestrator_apply_dryrun_test` stability vs dialect implementation progress: PASS (tests use only `tests/support/fake_dialect.rs` and do not depend on `stateql-dialect-*` crates).
  - `orchestrator_diffconfig_wiring_test` explicit wiring checks: PASS (`enable_drop`, `schema_search_path`, and `equivalence_policy` injection validated; dry-run includes `-- Skipped:` output when destructive ops are suppressed).
  - Quality gates:
    - `cargo +nightly-2026-02-20 fmt --all`: PASS.
    - `cargo clippy --workspace --all-targets -- -D warnings`: PASS.
    - `cargo nextest run --workspace`: PASS (93 passed, 0 failed).
- **Learnings:**
  - Patterns discovered: Keep orchestrator policy injection independent from `DiffConfig` ownership using a delegating policy wrapper (`&'static dyn EquivalencePolicy` -> `Arc<dyn EquivalencePolicy>`) so dialect-owned policy behavior is preserved without widening diff API lifetimes.
  - Gotchas encountered: Shared integration-test support modules are compiled per test target; helper methods used only by sibling tests must be guarded (`#[allow(dead_code)]`) to keep workspace-wide `-D warnings` green.
---
