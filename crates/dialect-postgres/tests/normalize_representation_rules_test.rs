use std::collections::BTreeMap;

use stateql_core::{
    Column, DataType, Dialect, Expr, Ident, Identity, Literal, PartitionBound, PartitionStrategy,
    SchemaObject, Table,
};
use stateql_dialect_postgres::PostgresDialect;

#[test]
fn normalizes_custom_type_aliases_and_case_for_comparison() {
    let dialect = PostgresDialect;
    let mut object = SchemaObject::Table(Table::named("users"));
    let SchemaObject::Table(table) = &mut object else {
        panic!("expected table object");
    };

    table.columns.push(test_column(
        "enabled",
        DataType::Custom("PG_CATALOG.BOOL".to_string()),
    ));
    table.columns.push(test_column(
        "tenant_type",
        DataType::Custom("\"MySchema\".\"MyType\"".to_string()),
    ));

    dialect.normalize(&mut object);

    let SchemaObject::Table(table) = object else {
        panic!("expected table object");
    };

    assert_eq!(table.columns[0].data_type, DataType::Boolean);
    assert_eq!(
        table.columns[1].data_type,
        DataType::Custom("myschema.mytype".to_string())
    );
}

#[test]
fn normalizes_sequence_representation_rules_for_serial_and_identity_columns() {
    let dialect = PostgresDialect;
    let sql = "CREATE TABLE users (id SERIAL, account_id BIGSERIAL, shard_id SMALLSERIAL, iid INT GENERATED ALWAYS AS IDENTITY, did INT GENERATED BY DEFAULT AS IDENTITY);";
    let objects = dialect.parse(sql).expect("postgres parse pipeline");

    assert_eq!(objects.len(), 1);
    let SchemaObject::Table(table) = &objects[0] else {
        panic!("expected table object");
    };

    let id = find_column(table, "id");
    assert_eq!(id.data_type, DataType::Integer);
    assert_nextval_default(id.default.as_ref(), "users_id_seq");

    let account_id = find_column(table, "account_id");
    assert_eq!(account_id.data_type, DataType::BigInt);
    assert_nextval_default(account_id.default.as_ref(), "users_account_id_seq");

    let shard_id = find_column(table, "shard_id");
    assert_eq!(shard_id.data_type, DataType::SmallInt);
    assert_nextval_default(shard_id.default.as_ref(), "users_shard_id_seq");

    let iid = find_column(table, "iid");
    assert_eq!(iid.identity, Some(identity(true)));
    assert!(iid.default.is_none());

    let did = find_column(table, "did");
    assert_eq!(did.identity, Some(identity(false)));
    assert!(did.default.is_none());
}

#[test]
fn folds_partition_children_into_parent_partition_elements() {
    let dialect = PostgresDialect;
    let sql = "\
CREATE TABLE events (id int) PARTITION BY RANGE (id);
CREATE TABLE events_p1 PARTITION OF events FOR VALUES FROM (1) TO (100);";

    let objects = dialect.parse(sql).expect("postgres parse pipeline");

    assert_eq!(objects.len(), 1);
    let SchemaObject::Table(table) = &objects[0] else {
        panic!("expected table object");
    };
    assert_eq!(table.name.name, Ident::unquoted("events"));

    let partition = table
        .partition
        .as_ref()
        .expect("partitioned parent should retain partition metadata");
    assert_eq!(partition.strategy, PartitionStrategy::Range);
    assert_eq!(partition.columns, vec![Ident::unquoted("id")]);
    assert_eq!(partition.partitions.len(), 1);

    let element = &partition.partitions[0];
    assert_eq!(element.name, Ident::unquoted("events_p1"));
    assert!(element.extra.is_empty());
    match element.bound.as_ref() {
        Some(PartitionBound::FromTo { from, to }) => {
            assert_eq!(from, &vec![Expr::Literal(Literal::Integer(1))]);
            assert_eq!(to, &vec![Expr::Literal(Literal::Integer(100))]);
        }
        other => panic!("expected FROM/TO partition bound, got {other:?}"),
    }
}

fn test_column(name: &str, data_type: DataType) -> Column {
    Column {
        name: Ident::unquoted(name),
        data_type,
        not_null: false,
        default: None,
        identity: None,
        generated: None,
        comment: None,
        collation: None,
        renamed_from: None,
        extra: BTreeMap::new(),
    }
}

fn find_column<'a>(table: &'a Table, name: &str) -> &'a Column {
    table
        .columns
        .iter()
        .find(|column| column.name == Ident::unquoted(name))
        .unwrap_or_else(|| panic!("missing expected column: {name}"))
}

fn assert_nextval_default(default: Option<&Expr>, expected_sequence_name: &str) {
    let Some(Expr::Raw(raw)) = default else {
        panic!("expected raw nextval default expression, got {default:?}");
    };
    assert!(
        raw.contains("nextval("),
        "expected nextval() in default expression: {raw}"
    );
    assert!(
        raw.contains(expected_sequence_name),
        "expected sequence name `{expected_sequence_name}` in default expression: {raw}"
    );
}

fn identity(always: bool) -> Identity {
    Identity {
        always,
        start: None,
        increment: None,
        min_value: None,
        max_value: None,
        cache: None,
        cycle: false,
    }
}
